local enabled = true
Plr = game.Players.LocalPlayer
Char = Plr.Character or Plr.CharacterAdded:wait()
Player = script.Parent.Parent
me = Player
mouse = Player:GetMouse()
run = game:GetService("RunService")
LeftShoulder = Player.Character.Torso["Left Shoulder"]
RightShoulder =   Player.Character.Torso["Right Shoulder"]
Colour = BrickColor.new("Toothpaste")
waittime = 9999


function onKeyDown(key)
if not enabled then return end
enabled = false
	Key = key:lower()
	
	if key == "z" then
		
		Run = game:GetService("RunService")
		game:GetService("Chat"):Chat(Player.Character.Head, "i get money")-- what it says untop head
		me.Character.Humanoid.WalkSpeed = 16

		local ETF = script.ET:Clone()
		ETF.Parent = Char.Head
		ETF.Enabled = true
		
		local ETF2 = script.Sound:Clone()
		ETF2.Parent = Char.Torso
		ETF2:Play()
		
		x = Instance.new("Part")
		x.Parent = me.Character.Torso
		x.Transparency = 1
		x.Reflectance = 0.4
		x.BrickColor = Colour
		x.Material = "SmoothPlastic"
		x.Size = Vector3.new(5,5,5)-- size
		x.Anchored = false
		x.CanCollide = false
		x.Name = Player.Name
		x.CFrame = me.Character.Torso.CFrame*CFrame.new(0,0,0)
		x.Shape = "Ball"
		w = Instance.new("Weld")
		w.Parent = me.Character.Torso
		w.Part0 = x
		w.Part1 = me.Character.Torso
		me.Character.Torso.Anchored = false
		
	shine = script.point:Clone()
	shine.Parent = x
	shine.Range = 10
	wait(60) -- How long it will stay for
	ETF:Destroy()
	ETF2:Destroy()
	
game.Debris:AddItem(x,10)
wait(10.1)
me.Character.Humanoid.WalkSpeed = 16		
			
		local d = me.Character:GetChildren()
						for i=1, #d do 
						if (d[i].className == "Hat") then 
						d[i].Handle.Anchored = false
						end 
						end
						local f = me.Character:GetChildren() 
						for i=1, #f do 
						if (f[i].className == "Part") then 
						f[i].Anchored = false
						end 
						end
	wait(waittime)
		end

enabled = true
end


	

mouse.KeyDown:connect(onKeyDown)

game:GetService("UserInputService").InputBegan:connect(function(inputobject,gpe)
	local code = inputobject.KeyCode
	local Key = ConvertCode(code)
	if CD == false and Key == ActivateKey and not gpe then
		CD = true
		EmperorEye()
	end
end)

game:GetService("UserInputService").InputBegan:connect(function(inputobject,gpe)
	local code = inputobject.KeyCode
	local Key = ConvertCode(code)
	if CD == false and Key == ActivateKey and not gpe then
		CD = true
		EmperorEye()
	end
end)
-----------------------------------
local Player = game.Players.LocalPlayer
local debounce = false

local function inputBegan(inputObject, gameProcessedEvent)
	if debounce then return end
	debounce = true
	
	if inputObject.KeyCode == Enum.KeyCode.X and not gameProcessedEvent and Player.Character then
		local humanoid = Player.Character:FindFirstChild("Humanoid")
		local torso = Player.Character:FindFirstChild("Torso")
		
		local head = Player.Character:FindFirstChild("Head")
		if head then
			game:GetService("Chat"):Chat(head, "Jump!")
		end
		
		if humanoid and torso then
			local jump = Instance.new("BodyForce")
			jump.Parent = torso
			jump.force = Vector3.new(0,6500,0)
			wait(.5)
			if jump then jump:Destroy() end
			
			if humanoid then
				humanoid.WalkSpeed = 2
				wait(2)
			end
			if humanoid then 
				humanoid.WalkSpeed = 16
				wait(10)
			end
		end	
	end
	debounce = false
end

game:GetService("UserInputService").InputBegan:connect(inputBegan)
-----------------------------
local Player = game.Players.LocalPlayer
Char = Player.Character or Player.CharacterAdded:wait()
local debounce = false
local Player = game.Players.LocalPlayer
Char = Player.Character or Player.CharacterAdded:wait()
local debounce = false
EffectColor = BrickColor.new("Really red")
Char = workspace[Player.Name]


local function inputBegan(inputObject, gameProcessedEvent)
if debounce then return end
debounce = true
if inputObject.KeyCode == Enum.KeyCode.C and not gameProcessedEvent and Player.Character then
local humanoid = Player.Character:FindFirstChild("Humanoid")
game:GetService("Chat"):Chat(Player.Character.Head, "Dash!")
if humanoid then
humanoid.WalkSpeed = 27
local stopit = false
local waitsy = coroutine.wrap(function()
	wait(2)
	stopit = true
end)
waitsy()
asd = false
local lasttorsopX = Char.Torso.Position.X
local lasttorsopZ = Char.Torso.Position.Z
while stopit == false do wait()
	if stopit == true then break end
	if asd == false then
	local kasda = coroutine.wrap(function()
		wait(0.85)
		asd = false
	end)
	kasda()
	
	if Char.Torso.Position.X ~= lasttorsopX or Char.Torso.Position.Z ~= lasttorsopZ then 
					lasttorsopX = Char.Torso.Position.X
					lasttorsopZ = Char.Torso.Position.Z
		for _,part in pairs(Char:GetChildren()) do
			local parttoclone = nil
			local savedcframe = nil
			if part.Name ~= "HumanoidRootPart" then
				if part:IsA("BasePart") then
					parttoclone = part
					savedcframe = part.CFrame
				elseif part:IsA("Hat") then
					parttoclone = part.Handle
					savedcframe = part.Handle.CFrame
				end
				if parttoclone ~= nil then
					local PartHolder = Instance.new("Model",Char.Torso)
					PartHolder.Name = ""
					local PC = Instance.new("Part")
					PC.Parent = workspace
					PC.FormFactor = "Custom"
					PC.CanCollide = false
					PC.Anchored = true
					PC.Name = parttoclone.Name
					PC.BrickColor = EffectColor
					PC.Size = parttoclone.Size
					PC.TopSurface = 0
					PC.BottomSurface = 0
					PC.Transparency = 0.5
					PC.CFrame = savedcframe
					PC.Parent = PartHolder
					PC.CanCollide = false
					PC.Changed:connect(function()
						PC.CanCollide = false
					end)
					if parttoclone:FindFirstChild("Mesh") then
						local Mesh = parttoclone.Mesh:Clone()
						Mesh.TextureId = ""
						Mesh.Parent = PC
					end
					local fade = coroutine.wrap(function()
						for i = 1, 20 do
						PC.Transparency = PC.Transparency + 0.1/4
						wait()
						end
					end)
					fade()
					local delete = coroutine.wrap(function()
					wait(0.1)
					PartHolder:Destroy()
					end)		
					delete()			
				end
			end
		end
		end
	end
end
if humanoid then
humanoid.WalkSpeed = 16
wait(9)
end
end
end
debounce = false
end

game:GetService("UserInputService").InputBegan:connect(inputBegan)
----------------------------------------------------------

ChatService = game:GetService("Chat")
RS = game:GetService("RunService").RenderStepped
ActivateKey = "v"
Plr = game.Players.LocalPlayer
Char = Plr.Character or Plr.CharacterAdded:wait()
CD = false
On = false
ReloadTime = 3
EagleSpots = {}
EagleBin = Instance.new("Message",Char)
Char = workspace:WaitForChild(Plr.Name)

function ConvertCode(keycode)
	local code = tostring(keycode)
	local pattern = "Enum.KeyCode%p%a"
	local anchor = "%p%a+"
	local finalkey = ""
	for t in code:gmatch(anchor) do
		for fc in t:gmatch("%a+") do
		finalkey = fc
		end
	end
	return finalkey:lower()
end

function EE()
	if On == false then
	On = true
	ChatService:Chat(Char,"Eagle Eye!",2)
	ReloadTime = 0
	local Tags = {}
	local co = coroutine.wrap(function()
		while On == true do RS:wait()
			for _,obj in pairs(workspace:GetChildren()) do
				if obj:FindFirstChild("Torso") then
					local found = false
					for _,p in next, Tags do
						if p == obj.Torso then
							found = true
							break
						end
					end
					if found == false then
					local E = Instance.new("Part",EagleBin)
					E.BrickColor = BrickColor.new("Black")
					local PlrAttempt = game.Players:GetPlayerFromCharacter(obj)
					if PlrAttempt ~= nil then
						E.BrickColor = PlrAttempt.TeamColor
					end
					E.Transparency = .4
					E.Anchored = false
					E.CanCollide = false
					E.FormFactor = "Custom"
					E.Size = Vector3.new(5,5,5)
					local EW = Instance.new("Weld",E)
					EW.Part0 = E
					EW.Part1 = obj.Torso
					table.insert(EagleSpots,E)
					table.insert(Tags,obj.Torso)
					end
				end
			end
		end
		return
	end)
	co()
	else
	On = false
	ChatService:Chat(Char,"Eagle Eye off!",2)
	ReloadTime = 3	
	for _,e in pairs(EagleSpots) do
		e:Destroy()
	end
	end
	wait(ReloadTime)
	CD = false
end

game:GetService("UserInputService").InputBegan:connect(function(inputobject,gpe)
	local code = inputobject.KeyCode
	local Key = ConvertCode(code)
	if CD == false and Key == ActivateKey and not gpe then
		CD = true
		EE()
	end
end)
